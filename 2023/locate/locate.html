<!DOCTYPE html>
<html>
	<head>
		<title>Locator</title>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
		<script>
			//https://www.movable-type.co.uk/scripts/latlong.html
			function neMeters(lat1, lon1, lat2, lon2)
			{
				const R = 6371e3; // metres
				const φ1 = lat1 * Math.PI/180; // φ, λ in radians
				const φ2 = lat2 * Math.PI/180;
				const Δφ = (lat2-lat1) * Math.PI/180;
				const Δλ = (lon2-lon1) * Math.PI/180;

				const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
						Math.cos(φ1) * Math.cos(φ2) *
						Math.sin(Δλ/2) * Math.sin(Δλ/2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

				const d = R * c; // in metres

				const y = Math.sin(Δλ) * Math.cos(φ2);
				const x = Math.cos(φ1)*Math.sin(φ2) -
						Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
				const θ = Math.atan2(y, x);
				const brng = (θ*180/Math.PI + 360) % 360; // in degrees

				return [d * Math.cos(θ), d * Math.sin(θ)];
			}

			//https://en.wikipedia.org/wiki/Alpha_beta_filter#Alpha_beta_gamma_filter
			class Kalman
			{
				constructor(σw, σv, lat1, long1, t)
				{
					//process covariance: typical deviation from an accurate model
					//noise covariance: typical deviation in the sensors
					this.then = t;
					this.σw = σw;
					this.σv = σv;
					this.lat1 = lat1;
					this.long1 = long1;
					this.φ1 = lat1 * Math.PI / 180;
					this.λ1 = long1 * Math.PI / 180;
					//console.log(this.lat1, this.long1, this.φ1, this.λ1);
					this.xn = 0;
					this.vn = 0;
					this.an = 0;
					this.xe = 0;
					this.ve = 0;
					this.ae = 0;
				}

				//https://en.wikipedia.org/wiki/Alpha_beta_filter#Alpha_beta_gamma_filter
				updateGPS(lat2, long2, t)
				{
					const T = Math.floor(t - this.then) * .001;
					this.then = t;

					//calculate update parameters
					/*const λ = this.σw * T * T / this.σv;
					const b = λ / 2 - 3;
					const c = λ / 2 + 3;
					const d = -1;
					const p = c - b * b / 3;
					const q = 2 * b * b * b / 27 - b * c / 3 + d;
					const v = Math.sqrt(q * q + 4 * p * p * p / 27);
					const z = - Math.pow(q + v / 2, 1/3);
					const s = z - p / (3 * z) - b / 3;*/
					const α = 1;//1 - s * s;
					const β = 1.5;//2 * (1 - s) * (1 - s);
					const γ = 1.5;//β * β / (2 * α);
					//$('#loc')[0].innerHTML += " (("+T+")," + λ + "," + b + "," + c + "," + d + "," + p + "," + q + "," + v + "," + z + "," + s + "," + α + "," + β + "," + γ + ")";

					//project from previous information
					this.xn += T * this.vn + T * T / 2 * this.an;
					this.vn += T * this.an;
					this.xe += T * this.ve + T * T / 2 * this.ae;
					this.ve += T * this.ae;

					//calculate error
					const newLoc = neMeters(this.lat1, this.long1, lat2, long2);
					const rn = newLoc[0] - this.xn;
					const re = newLoc[1] - this.xe;

					//correct location
					this.xn += α * rn; this.vn += β / T * rn; this.an += 2 * γ / (T * T) * rn;
					this.xe += α * re; this.ve += β / T * re; this.ae += 2 * γ / (T * T) * re;
				}

				currentLoc()
				{
					const d = Math.sqrt(this.xn * this.xn + this.xe * this.xe);
					const brng = Math.atan2(this.xe, this.xn);
					//console.log(this.xe, this.xn, this.φ1, this.λ1);
					if(!brng) return this.φ1 * 180 / Math.PI + "N, " + this.λ1 * 180 / Math.PI + "E\n(0m N, 0mE of start)"
					const R = 6371e3;
					//console.log(this.xe, this.xn, d, brng);
					const φ2 = Math.asin(Math.sin(this.φ1)*Math.cos(d/R) +
							Math.cos(this.φ1)*Math.sin(d/R)*Math.cos(brng) );
					const λ2 = this.λ1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(this.φ1),
							Math.cos(d/R)-Math.sin(this.φ1)*Math.sin(φ2));
					return φ2 * 180 / Math.PI + "N, " + λ2 * 180 / Math.PI + "E\n" +
							"(" + Math.floor(this.xn) + "m N, " + Math.floor(this.xe) + "m E of start)";
				}
			}

		</script>
	</head>
	<body>
		<input type="button" value="Start" onclick="start()">
		<pre id="loc"></pre>
		<pre id="sense"></pre>
		<script>
			const PROC_ERR = 1;
			const NOISE_ERR = 10;

			var k;

			function start()
			{
				if(navigator.geolocation)
				{
					navigator.geolocation.getCurrentPosition(function(initPos){
						//console.log(initPos);
						k = new Kalman(PROC_ERR, NOISE_ERR, initPos.coords.latitude, initPos.coords.longitude, initPos.timestamp);
						$('#loc')[0].innerHTML = k.currentLoc();
						//navigator.geolocation.watchPosition(posUpdate);
						//setInterval(navigator.geolocation.getCurrentPosition(posUpdate,function(err){console.log(err)}, {enableHighAccuracy: true}), 1000);
						//setInterval(function(){$('#loc')[0].innerHTML += " " + k.currentLoc();}, 1000);
						navigator.geolocation.watchPosition(posUpdate);
					});
				}
			}

			function rotate(v, q, d=-1)
			{
				if(!q) return [0,0,0];
				[x,y,z] = v;
				[i,j,k,r] = q;
				o = [x * (1 - 2 * (j * j + k * k)) + y * 2 * (i * j + k * r) + z * 2 * (i * k - j * r),
					x * 2 * (i * j - k * r) + y * (1 - 2 * (i * i + k * k)) + z * 2 * (j * k + i * r),
					x * 2 * (i * k + j * r) + y * 2 * (j * k - i * r) + z * (1 - 2 * (i * i + j * j))];
				if(d < 0) return o
				return [Math.round(o[0]*Math.pow(10,d))/Math.pow(10,d), Math.round(o[1]*Math.pow(10,d))/Math.pow(10,d), Math.round(o[2]*Math.pow(10,d))/Math.pow(10,d)]
			}

			function posUpdate(position)
			{
				//$('#loc')[0].innerHTML += " " + position.coords.latitude + "," + position.coords.longitude + "(" + position.timestamp % 100000 + ")";
				k.updateGPS(position.coords.latitude, position.coords.longitude, position.timestamp);
				$('#loc')[0].innerHTML = k.currentLoc();
			}

			var dat = [[0, 0, 0],[0,0,0],[0,0,0],[0,0,0],[0,0,0,0],[0,0,0]];
			setInterval(function(){
				var s = "";
				for(var i = 0; i < dat.length; i++)
				{
					for(var j = 0; j < dat[i].length; j++)
					{
						s += (dat[i][j] >= 0 ? ' ' : '') + dat[i][j] + '\t';
					}
					s += '\n';
				}
				$('#sense')[0].innerHTML = s;
			}, 10);

			const acl = new Accelerometer({ frequency: 60 });
			acl.addEventListener("reading", () => {dat[0] = [Math.round(acl.x*100)/100, Math.round(acl.y*100)/100, Math.round(acl.z*100)/100]});
			acl.start();

			const grav = new GravitySensor({ frequency: 60 });
			grav.addEventListener("reading", (e) => {dat[1] = [Math.round(grav.x*100)/100, Math.round(grav.y*100)/100, Math.round(grav.z*100)/100]});
			grav.start();

			const gyro = new Gyroscope({ frequency: 60 });
			gyro.addEventListener("reading", (e) => {dat[2] = [Math.round(gyro.x*100)/100, Math.round(gyro.y*100)/100, Math.round(gyro.z*100)/100]});
			gyro.start();

			const linacc = new LinearAccelerationSensor({frequency: 60});
			linacc.addEventListener("reading", (e) => {dat[3] = [Math.round(linacc.x*100)/100, Math.round(linacc.y*100)/100, Math.round(linacc.z*100)/100]});
			linacc.start();

			const sensor = new AbsoluteOrientationSensor();
			Promise.all([
				navigator.permissions.query({ name: "accelerometer" }),
				navigator.permissions.query({ name: "magnetometer" }),
				navigator.permissions.query({ name: "gyroscope" }),
			]).then((results) => {
			if (results.every((result) => result.state === "granted")) {
				sensor.addEventListener("reading", (e) => {dat[4] = [Math.round(sensor.quaternion[0]*100)/100, Math.round(sensor.quaternion[1]*100)/100, Math.round(sensor.quaternion[2]*100)/100, Math.round(sensor.quaternion[3]*100)/100]});
				sensor.start();
			} else { dat[4] = [0]; }});

			setInterval(function(){dat[5] = rotate([linacc.x, linacc.y, linacc.z], sensor.quaternion, 3)}, 20);
		</script>
	</body>
	<footer style="position: fixed; bottom: 0">
		3-26-2023 10:05 AM
	</footer>
</html>