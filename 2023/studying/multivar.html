<!doctype HTML>
<html>
	<head>
		<title>Multivariable Calc Studying</title>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js"
			integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
			crossorigin="anonymous"></script>
	</head>
	<body onload="next()">
		<label>Progress: </label><p id="toStudy"></p>
		<p id="q"></p>
		<input type="text" id="in" autocomplete="off" style="width:80%"><br>
		<div id="nxt">
			<input type="button" value="Appeal" onclick="appeal()"><br>
			<input type="button" value="Next" onclick="next()"><br>
		</div>
		<p id="resp"></p>
		<div id="a" style="display:none"></div>
		<script>
const DAT = `
11.1: Cycloid parametrization in theta given r	r*(theta-sin(theta)), r*(1-cos(theta))
11.2: Parametric dy/dx using t	(dy/dt)/(dx/dt)
11.2: Parametric arc length integral in t on alpha..beta	int[sqrt(x'^2+y'^2)*dt, alpha, beta]
11.2: Parametric area integral in t on alpha..beta	int[y*x'*dt, alpha, beta]
11.3: Polar derivative dy/dx using theta	(r'*sin(theta)+r*cos(theta))/(r'*cos(theta)-r*sin(theta))
11.4: Polar area integral in theta on a..b	int[r^2/2*dtheta, a, b]
11.4: Polar arc length integral in theta on a..b	int[sqrt(r^2+r'^2)*dtheta, a, b]
11.5: Focus-directrix parabola form	x^2 = 4*p*y
11.5: Ellipse standard form	x^2/a^2+y^2/b^2 = 1
11.5: Ellipse focal distance equation	c^2 = a^2-b^2
11.5: Hyperbola standard form	x^2/a^2-y^2/b^2 = 1
11.5: Hyperbola focal distance equation	c^2 = a^2+b^2
11.5: Hyperbola asymptotic slope magnitude	b/a
11.6: Given focus-directrix distance d and eccentricity e, polar conic equation (phase is irrelevant)	r = e*d/(1+e*cos(theta))
12.1: If a sequence is bounded and monotonic, it is	convergent
12.2: If s[n] is the nth partial sum of a series and the sequence s[n] is convergent, the series is	convergent
12.2: Geometric series are convergent for	abs(r) < 1
12.2: Name the test - Unless we have a[n] converges to 0, sum[a[n]] must diverge	test for divergence
12.3: Name the test - sum[a[n]] has the same limiting behavior as the corresponding integral when the function is monotonic	integral test
12.3: The p-series sum[1/n^p] is convergent for	p > 1
12.3: Remainder estimate for the integral test, of R[n] = s-s[n]	int[f(x)*dx, n+1, inf] <= R[n] <= int[f(x)*dx, n, inf]
12.4: Rather than the direct comparison test for series, it may be convenient to take the ratio of two sequences and do the	limit comparison test
12.5: Name the test - convergence when an alternating series has magnitudes monotonically decreasing to 0	alternating series test
12.5: Alternating series estimation of R[n] = s-s[n] (s=sum[(-1)^(n-1)*b[n]])	abs(R[n]) <= b[n+1]
12.6: Name the test - check the limit of the magnitudes of successive fractions (!=1) for absolute convergence	ratio test
12.6: Name the test - check absolute convergence by the limit of the nth roots (!=1)	root test
12.6: What type of series can be rearranged to produce any sum?	conditionally convergent
12.10: Taylor's inequality - upper bound on abs(R[n]) given a neighborhood at a where the n+1... derivatives are bounded by M	M/(n+1)!*abs(x-a)^(n+1)
12.10: To prove the accuracy of a taylor series, we use _ to show R[n]->0	Taylor's inequality
12.10: Binomial series ith term for (1+x)^k (show leading 2, trailing 1)	k*(k-1)***(k-i)/i!*x^i
13.3: Direction cosine formula for a with unit vector iHat	cos(alpha) = (a dot iHat)/abs(a)
13.3: comp[a](b)	(a dot b)/abs(a)
13.3: proj[a](b)	(a dot b)/abs(a)^2*a
13.4: Determinant form of a cross b	det([[iHat, jHat, kHat][a1, a2, a3][b1, b2, b3]])
13.4: a dot (b cross c)	(a cross b) dot c
13.4: a cross (b cross c)	b*(a dot c)-c*(a dot b)
13.4: The parallelipiped on a,b,c has volume	abs(a dot (b cross c))
13.4: Determinant form of scalar triple product a dot (b cross c)	det([[a1, a2, a3][b1, b2, b3][c1, c2, c3]])
13.5: Vector equation of a line	r = r[0]+t*v
13.5: Symmetric equations of a line with direction vector v=<a,b,c>	(x-x[0])/a = (y-y[0])/b = (z-z[0])/c
13.5: Vector equation of a plane	n dot (r-r[0]) = 0
13.5: Scalar equation of a plane with n=<a,b,c>	a*(x-x[0])+b*(y-y[0])+c*(z-z[0]) = 0
13.5: Plane standard form	a*x+b*y+c*z+d = 0
13.5: For a plane, d=	-a*x[0]-b*y[0]-c*z[0]
13.6: Classify x^2/a^2+y^2/b^2+z^2/c^2=1	ellipsoid
13.6: Classify z/c=x^2/a^2+y^2/b^2	elliptic paraboloid
13.6: Classify z/c=x^2/a^2-y^2/b^2	hyperbolic paraboloid
13.6: Classify z^2/c^2=x^2/a^2+y^2/b^2	cone
13.6: Classify x^2/a^2+y^2/b^2-z^2/c^2=1	hyperboloid of one sheet
13.6: Classify -x^2/a^2-y^2/b^2+z^2/c^2=1	hyperboloid of two sheets
14.2: Unit tangent vector T given vector function r	r'/abs(r')
14.3: Arc length L along vector function r	int[abs(r')*dt, a, b]
14.3: Smooth r(t) satisfies r'(t) _ and _ âˆ€t	continuous, nonzero
14.3: Curvature kappa given T	abs(dT/ds)
14.3: Curvature kappa given T, r	abs(T')/abs(r')
14.3: Curvature kappa given r	abs(r' cross r'')/abs(r')^3
14.3: Curvature kappa given r=<x,f(x)>	abs(f'')/(1+f'^2)^(3/2)
14.3: Principal unit normal vector N	T'/abs(T')
14.3: Binormal unit vector B	T cross N
14.3: Plane containing N and B	normal plane
14.3: Plane containing T and N	osculating plane
14.3: Radius of the osculating circle	1/kappa
14.4: Tangential and Normal form of acceleration a=	abs(v)'*T+kappa*v^2*N
14.4: Proving Kepler's 1st Law by h = _ (prove constant), v cross h = _ (integrate from the _), abs(h)^2 = vector triple product = _	r cross v, G*M*u+c, product rule, G*M*abs(r)+abs(r)*abs(c)*cos(theta)
15.1: Points such that f(x,y)=k (constant) make up a	level curve
15.2: 2d limits - check different axes & lines, but beware; delta-epsilon shortcut uses the _ to evaluate limits (sometimes in _)	squeeze theorem, polar
15.3: Name the theorem - when all necessary partials are continuous, order of multiple partials is irrelevant	Clairaut's theorem
15.4: z=f(x,y) tangent plane (partials evaluated at the point of interest)	z-z[0] = f[x]*(x-x[0])+f[y]*(y-y[0])
15.4: Where f[x] and f[y] are _, f is differentiable	continuous
15.6: Directional derivative D[u](f)	del*f dot u
15.6: D[u](f) is maximized when _ is parallel to _	u, del*f
15.6: Level surface F(x,y,z)=0 tangent plane	F[x]*(x-x[0])+F[y]*(y-y[0])+F[z]*(z-z[0]) = 0
15.7: f(x,y) has critical points where	f[x]=0, f[y]=0
15.7: Second-derivative test for f(x,y) at (a,b) gives local min or max where curvature (ish) D>0 (<0 saddle, =0 ?) where D=	f[x^2]*f[y^2]-f[xy]^2
15.7: A closed set will give an absolute max and min when f is _ on it	continuous
15.8: Maxima and minima of f(x,y,z) constrained to g(x,y,z)=k occur somewhere where	del*f = lambda*del*g
15.8: Lagrange multiplier constraint on maxima/minima using constraints g,h	del*f = lambda*del*g+mu*del*h
16.4: int_R[f(x,y)*dA] to polar form	int_R[f(r*cos(theta),r*sin(theta))*r*dr*dtheta]
16.5: Laminar moment about the x-axis given density function rho in D: M[x]=	int_D[y*rho(x,y)*dA]
16.5: Laminar center of mass x-coordinate given moment about the y-axis	M[y]/m
16.5: Laminar moment of inertia about the x-axis given density rho in D: I[x]=	int_D[y^2*rho(x,y)*dA]
16.5: Given moment of inertia I for mass m, the radius of gyration R=	sqrt(I/m)
16.6: 3d moment about the xy plane given density rho in E: M[xy]=	int_E[z*rho(x,y,z)*dV]
16.6: 3d center of mass x-coordinate given moment about the yz plane	M[yz]/m
16.6: 3d moment of inertia about the x-axis given density rho in E: I[x]=	int_E[(y^2+z^2)*rho(x,y,z)*dV]
16.7: int_E[f(x,y,z)*dV] to cylindrical form on z-axis	int_E[f(r*cos(theta),r*sin(theta),z)*r*dz*dr*dtheta]
16.8: int_E[f(x,y,z)*dV] to spherical form on z-axis	int_E[f(rho*sin(phi)*cos(theta),rho*sin(phi)*sin(theta),rho*cos(phi))*rho^2*sin(phi)*drho*dtheta*dphi]
16.9: Given x(u,v) and y(u,v), the Jacobian of transformation d(x,y)/d(u,v)=	det([[x[u],x[v]][y[u],y[v]]])
16.9: int_R[f(x,y)*dA] transformation into x(u,v) y(u,v) one-to-one (except perhaps on the boundary)	int_R[f(x(u,v),y(u,v))*abs(d(x,y)/d(u,v))*du*dv]
16.9: 3d Jacobian of transformation d(x,y,z)/d(u,v,w)	det([[x[u],x[v],x[w]][y[u],y[v],y[w]][z[u],z[v],z[w]]])
`;
		
		var ops = DAT.split('\n');
		for(var i = 0; i < ops.length; i++)
		{
			if(!ops[i].includes('\t') || ops[i].indexOf('\t')==0)
			{
				ops.splice(i, 1);
				i--;
			}
		}
		var qs = [];
		var as = [];
		for(var i = 0; i < ops.length; i++)
		{
			qs.push(ops[i].split('\t')[0]);
			as.push(ops[i].split('\t')[1]);
		}
		var showing = false;
		var idx = 0;
		var errs = 0;
		var appealed = false;

		$('#in').keypress(function(event)
		{
			if (event.keyCode == 13 || event.which == 13)
			{
				event.preventDefault();
				if(!showing)
				{
					if($('#in')[0].value.toLowerCase() === $('#a')[0].innerText.toLowerCase())
					{
						$('#resp')[0].innerText = "Correct! The answer is:";
						qs.splice(idx, 1);
						as.splice(idx, 1);
						appealed = true;
					}
					else
					{
						$('#resp')[0].innerText = "Incorrect. The answer is:";
						errs++;
					}
					$('#a')[0].style.display = "inline";
					$('#nxt')[0].style.display = "block";
					showing = true;
					$('#toStudy')[0].innerText = qs.length + ' remaining, ' + errs + ' mistakes';
				}
				else
				{
					next();
				}
			}
		});

		function appeal()
		{
			if(!appealed)
			{
				$('#resp')[0].innerText = "(Appealed)";
				qs.splice(idx, 1);
				as.splice(idx, 1);
				errs--;
				appealed = true;
			}
		}

		function next()
		{
			$('#toStudy')[0].innerText = qs.length + ' remaining, ' + errs + ' mistakes';
			if(qs.length == 0) return;
			idx = Math.floor(Math.random() * qs.length);
			$('#q')[0].innerText = qs[idx];
			$('#in')[0].value = '';
			$('#resp')[0].innerText = '';
			$('#a')[0].innerText = as[idx];
			$('#a')[0].style.display = "none";
			$('#nxt')[0].style.display = "none";
			showing = false;
			appealed = false;
		}
		</script>
	</body>
</html>