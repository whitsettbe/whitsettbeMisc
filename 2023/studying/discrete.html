<!doctype HTML>
<html>
	<head>
		<title>Discrete Math Studying</title>
		<script src="https://code.jquery.com/jquery-3.5.1.min.js"
			integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
			crossorigin="anonymous"></script>
	</head>
	<body onload="next()">
		<label>Progress: </label><p id="toStudy"></p>
		<p id="q"></p>
		<input type="text" id="in" autocomplete="off" style="width:80%"><br>
		<div id="nxt">
			<input type="button" value="Appeal" onclick="appeal()"><br>
			<input type="button" value="Next" onclick="next()"><br>
		</div>
		<p id="resp"></p>
		<div id="a" style="display:none"></div>
		<script>
const DAT = `
1.1: Critical path analysis horizontal diagram name	PERT diagram
1.4: Evaluate polynomial by adding successive terms	polynomial evaluation
1.4: Evaluate polynomial by adding coefficients and multiplying	Horner's algorithm
2.1: A∪B operation name	union
2.1: A∩B operation name	intersection
2.1: -A operation name	complement
2.1: {(a,b): a∈A and b∈B} notation, name	AxB, Cartesian Product
2.2: Relations from A to B are subsets of	AxB
2.2: Term for a subset of SxS	relation on S
2.2: Three qualities of an equivalence relation	reflexive, symmetric, transitive
2.2: Given equivalence relation R, [x] is an	equivalence class
2.4: When xRy and yRx implies x=y always, R is	antisymmetric
2.4: Three qualities of a partial ordering relation	reflexive, antisymmetric, transitive
2.4: Given R1 partial ordering of S1, R2 partial ordering of S2, lexicographic order is a partial order of	S1xS2
2.4: Lexicographic order (from R1, R2) R={((a1,a2),(b1,b2)) | _ or _}	a1!=b1 and a1R1b1, a1=b1 and a2R2b2
2.4: Subset-restricted relation R'=	R and (S'xS')
2.4: When xRy or yRx for all x, y in S, R is a	total order
2.4: Partial order vertically-oriented diagram name	Hasse diagram
2.4: Construct total order from repeatedly "popping" minimal elements of S	Topological sorting algorithm
2.5: y s.t. xfy	image of x under f
2.5: Function inputs are from the domain, and outputs are from the	codomain
2.5: Two qualities of a one-to-one correspondence	one-to-one, onto
2.5: A function is "onto" if there is equality between the	codomain, range
2.6: In inductive proof, the quality that always holds is the	loop invariant
3.1: Nonempty finite set V along with a set E of 2-element subsets of V	graph
3.1: Notation for adjacency matrix of a graph G	A(G)
3.1: When two graphs are identical up to labeling, they are _ by _	isomorphic, isomorphism
3.1: Property fixed under isomorphism	isomorphism invariant
3.2: Multigraphs also contain	loops, parallel edges
3.2: Pick a point with edges, construct a cycle on it (popped from the graph) to update the order, repeat	Euler Circuit Algorithm
3.2: Sufficient Hamiltonian Cycle criterion - with n vertices, all degrees are >=	n/2
3.2: Bitstring ordering with minimal Hamming distances	Gray code
3.3: Traverse by always visiting the nearest (unweighted) vertex	Breadth-First Search
3.3: Traverse by always visiting the nearest (weighted) vertex	Dijkstra's Algorithm
3.5: If a digraph has a directed path from any vertex to any other vertex, it is	strongly connected
3.5: Assigning directions to a complete graph gives	tournament
4.1: Connected graph without cycles	tree
4.1: Identify a tree by list of parents of successive minimal leaves	Prufer's algorithm
4.3: Repeatedly choose min/max-weight edges to yet-unvisited vertices	Prim's MST Algorithm
4.3: Repeatedly choose min/max-weight edges while preventing cycles	Kruskal's MST Algorithm
4.4: DFS MST includes _ edges and excludes _ edges and numbers starting with _	tree, back, 1
4.4: As long as there is not a _ in a graph, give tree edges DFS# ascending and back descending for a _	bridge, strongly-connected digraph
4.5: Digraph whose undirected form is a tree and which has all indegrees 1 except for a vertex with indegree 0	rooted tree
4.6: Rooted tree where all vertices have at most two children, each "ordered" L/R	binary tree
4.7: Repeatedly join trees of minimal roots with new roots (sum of two prev roots)	Huffman's Optimal Binary Tree Algorithm
4.7: By the _, initial bits of a character cannot represent another character	prefix property
4.7: Binary tree where inorder traversal gives ascending sort of vertex labels	binary search tree
5.1: A sequence of distinct x[i] s.t. x[i]∈S[i] for i∈[1,n]	system of distinct representatives
5.1: {S[i]} has a system of distinct representatives iff all I⊆[1,n] have |U{S[i] s.t. i∈I}|>=|I|	Hall's Theorem
5.2: Property of a graph s.t. V has disjoint subsets V1, V2 such that e=(v1, v2) ∀e∈E	bipartite
5.2: Set M of edges s.t. no vertex is incident with multiple edges in M	matching
5.2: Bipartite graph matrix has _ and _ labeling rows and columns, respectively	V1, V2
5.2: Bipartite graph matrix matching is equivalent to constructing a _	independent set of 1s
5.2: Set of vertices s.t. every edge is incident to at least one vertex in the set	covering
5.2: No matching is larger than any covering; if they are equal, we have a _ and _	maximum matching, minimum covering
5.2: Bipartite graph matrix covering is equivalent to constructing a set of _ containing all the _	lines, 1s
5.3: Independent Set Algorithm Step 1 - label each _ containing _ with a #	column, no starred 1
5.3: Independent Set Algorithm Step 2 - alternately scan labeled columns/rows by labeling the rows/columns with _/_ 1s, respectively, until done scanning or some _ contains _	unstarred, starred, labeled row, no starred 1
5.3: Independent Set Algorithm Step 3 - flip star states on the 1s backwards from the _ with _, using the labels	labeled row, no starred 1
5.3: Independent Set Algorithm operation count on an mxn matrix	(3*m*n+m+n)*min(m,n)
5.4: If the matching is unimproved, Independent Set Algorithm _ and _ form a _	labeled rows, unlabeled columns, minimum covering
5.4: If the matching is unimproved, Independent Set Algorithm _ form _ from Hall's Theorem	unlabeled rows, I
5.4: To solve bottleneck problem minimizing worst job cost, search for a _ as assumed cost _	matching, increases
5.5: Pad 0s -> square, -rowmins, enlarge 0s, -min non-covered (add to doubly-covered) & repeat, add chosen initial values to get _ by _	minimum independent set of n entries, Hungarian Algorithm
5.5: To find maximum independent set of n entries, a[i,j]-->_ and use the _	-a[i,j], Hungarian Algorithm
6.1: _ is a nonnegative-weighted digraph with exactly one vertex with indeg=0 (_), exactly one vertex with outdeg=0 (_)	network, source, sink
6.1: Function f acting on each edge s.t. 0<=f(e)<=cap(e) and sum[f, inarcs]=sum[f, outarcs] ∀v∈(V-{source, sink})	flow
6.1: Flow out of the source = flow into the sink = the _ of the flow	value
6.1: Partition of source from sink	cut
6.1: Capacity of a cut is the sum of arc capacities from the subgraph with the _ to the one with the _	source, sink
6.2: Flow Augmentation Algorithm Step 1 - label the _ with (_, _, _)	source, source, +, inf
6.2: Flow Augmentation Algorithm Step 2 - repeatedly scan labeled verts v (u,+/-,a) by labeling adjs with _, forward _ and backward _, max poss. arc change until _ labeled (or done scanning)	v, +, -, sink
6.2: Flow Augmentation Algorithm Step 3 - starting from the _, add/subtract flow at the _ to arcs backwards until reaching the _	sink, sink, source
6.3: In a transportation network, Flow Augmentation on a maximum flow gives a _ by the _ and _ vertices	minimum cut, labeled, unlabeled
6.3: Flow Augmentation Algorithm operation count on m arcs, n vertices	m^2*n
6.4: Flow/cut problems may also be used to find a _ for a bipartite graph	maximum matching
6.4: Max decrease in vertices from a subset of V1 to the image in V2 is the _ of G	deficiency
`;
		
		var ops = DAT.split('\n');
		for(var i = 0; i < ops.length; i++)
		{
			if(!ops[i].includes('\t') || ops[i].indexOf('\t')==0)
			{
				ops.splice(i, 1);
				i--;
			}
		}
		var qs = [];
		var as = [];
		for(var i = 0; i < ops.length; i++)
		{
			qs.push(ops[i].split('\t')[0]);
			as.push(ops[i].split('\t')[1]);
		}
		var showing = false;
		var idx = 0;
		var errs = 0;
		var appealed = false;

		$('#in').keypress(function(event)
		{
			if (event.keyCode == 13 || event.which == 13)
			{
				event.preventDefault();
				if(!showing)
				{
					if($('#in')[0].value.toLowerCase() === $('#a')[0].innerText.toLowerCase())
					{
						$('#resp')[0].innerText = "Correct! The answer is:";
						qs.splice(idx, 1);
						as.splice(idx, 1);
						appealed = true;
					}
					else
					{
						$('#resp')[0].innerText = "Incorrect. The answer is:";
						errs++;
					}
					$('#a')[0].style.display = "inline";
					$('#nxt')[0].style.display = "block";
					showing = true;
					$('#toStudy')[0].innerText = qs.length + ' remaining, ' + errs + ' mistakes';
				}
				else
				{
					next();
				}
			}
		});

		function appeal()
		{
			if(!appealed)
			{
				$('#resp')[0].innerText = "(Appealed)";
				qs.splice(idx, 1);
				as.splice(idx, 1);
				errs--;
				appealed = true;
			}
		}

		function next()
		{
			$('#toStudy')[0].innerText = qs.length + ' remaining, ' + errs + ' mistakes';
			if(qs.length == 0) return;
			idx = Math.floor(Math.random() * qs.length);
			$('#q')[0].innerText = qs[idx];
			$('#in')[0].value = '';
			$('#resp')[0].innerText = '';
			$('#a')[0].innerText = as[idx];
			$('#a')[0].style.display = "none";
			$('#nxt')[0].style.display = "none";
			showing = false;
			appealed = false;
		}
		</script>
	</body>
</html>